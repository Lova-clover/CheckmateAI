import React, { useState, useEffect } from 'react';
import Chessboard from 'chessboardjsx';
import { Chess, Square } from 'chess.js';
import { initializeApp } from "firebase/app";
import { getAuth, onAuthStateChanged, signInWithEmailAndPassword, signOut } from "firebase/auth";

const firebaseConfig = {
  apiKey: "üî•ÎãπÏã†Ïùò ÌÇ§",
  authDomain: "üî•ÎãπÏã†Ïùò ÎèÑÎ©îÏù∏",
  projectId: "CheckmateAI",
  appId: "üî•ÎãπÏã†Ïùò AppID"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);

function App() {
  const [game, setGame] = useState(new Chess());
  const [position, setPosition] = useState('start');
  const [boardWidth, setBoardWidth] = useState(window.innerWidth > 500 ? 500 : window.innerWidth - 20);

  const [promotionModalOpen, setPromotionModalOpen] = useState(false);
  const [promotionPending, setPromotionPending] = useState<{ from: Square; to: Square } | null>(null);
  const [movePairs, setMovePairs] = useState<[string, string | null][]>([]);
  const [winnerMessage, setWinnerMessage] = useState<string>('');
  const [useAI, setUseAI] = useState(true); // trueÎ©¥ AI ÎåÄÍµ≠, falseÎ©¥ ÏÇ¨Îûå vs ÏÇ¨Îûå
  const [aiLevel, setAiLevel] = useState<'easy' | 'medium' | 'hard'>('easy'); // ÎÇúÏù¥ÎèÑ
  const [puzzleFen, setPuzzleFen] = useState('');
  const [puzzleGame, setPuzzleGame] = useState(new Chess());
  const [puzzleSolution, setPuzzleSolution] = useState<string[]>([]);
  const [puzzleMessage, setPuzzleMessage] = useState('');
  const [puzzleActive, setPuzzleActive] = useState(false);
  const [puzzleHint, setPuzzleHint] = useState('');
  const [showHint, setShowHint] = useState(false);
  const [showSolution, setShowSolution] = useState(false);
  const [userMoves, setUserMoves] = useState<string[]>([]);
  const [userId, setUserId] = useState<string | null>(null);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState(''); 
  const [puzzleId, setPuzzleId] = useState<string>('');
  const BACKEND_URL =
    process.env.NODE_ENV === 'production'
      ? 'https://checkmateai-s5qg.onrender.com/' // üü¢ Î∞∞Ìè¨Îêú Flask ÏÑúÎ≤Ñ Ï£ºÏÜå
      : 'http://localhost:5000';              // üß™ Î°úÏª¨ Í∞úÎ∞úÏö©   

  useEffect(() => {
    onAuthStateChanged(auth, (user) => {
      if (user) setUserId(user.uid);
      else setUserId(null);
    });
  }, []);

   const handleLogin = async () => {
    try {
      const userCred = await signInWithEmailAndPassword(auth, email, password);
      setUserId(userCred.user.uid);
    } catch (e: any) {
      alert("Î°úÍ∑∏Ïù∏ Ïã§Ìå®: " + e.message);
    }
  };

  const handleLogout = () => {
    signOut(auth);
  };

  useEffect(() => {
    const handleResize = () => {
      setBoardWidth(window.innerWidth > 500 ? 500 : window.innerWidth - 20);
    };
    window.addEventListener('resize', handleResize);
    return () => window.removeEventListener('resize', handleResize);
  }, []);

  const updateMovePairs = (historyVerbose: any[]) => {
    const pairs: [string, string | null][] = [];
    for (let i = 0; i < historyVerbose.length; i += 2) {
      const white = historyVerbose[i]?.san ?? '';
      const black = historyVerbose[i + 1]?.san ?? null;
      pairs.push([white, black]);
    }
    setMovePairs(pairs);
  };

  const isPromotionMove = (from: Square, to: Square) => {
    const piece = game.get(from);
    if (!piece || piece.type !== 'p') return false;
    const rank = to[1];
    return (piece.color === 'w' && rank === '8') || (piece.color === 'b' && rank === '1');
  };

  const handlePromotion = (from: Square, to: Square) => {
    setPromotionPending({ from, to });
    setPromotionModalOpen(true);
  };

  const confirmPromotion = (promotion: 'q' | 'r' | 'b' | 'n') => {
    if (!promotionPending) return;

    const moveObj = {
      from: promotionPending.from,
      to: promotionPending.to,
      promotion,
    };

    // üõ†Ô∏è Ï≤¥ÌÅ¨: Ìï¥Îãπ moveÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÏÇ¨Ï†ÑÏóê ÌôïÏù∏
    const legalMoves = game.moves({ verbose: true });
    const isLegal = legalMoves.some(
      (m) =>
        m.from === moveObj.from &&
        m.to === moveObj.to &&
        m.promotion === promotion
    );

    if (!isLegal) {
      console.warn('‚ö†Ô∏è Illegal promotion move ÏãúÎèÑÎê®:', moveObj);
      setPromotionModalOpen(false);
      setPromotionPending(null);
      return;
    }

    const move = game.move(moveObj);

    if (move) {
      setPosition(game.fen());
      updateMovePairs(game.history({ verbose: true }));
      checkGameOver(game);
    }

    setPromotionModalOpen(false);
    setPromotionPending(null);
  };


  const checkGameOver = (gameInstance: Chess) => {
    if (gameInstance.isCheckmate()) {
      const winner = gameInstance.turn() === 'w' ? 'Ìùë' : 'Î∞±';
      setWinnerMessage(`Ï≤¥ÌÅ¨Î©îÏù¥Ìä∏! ${winner} ÏäπÎ¶¨!`);
    } else if (gameInstance.isDraw()) {
      setWinnerMessage('Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§.');
    } else if (gameInstance.isStalemate()) {
      setWinnerMessage('Ïä§ÌÖåÏùºÎ©îÏù¥Ìä∏! Î¨¥ÏäπÎ∂ÄÏûÖÎãàÎã§.');
    } else if (gameInstance.isGameOver()) {
      setWinnerMessage('Í≤åÏûÑÏù¥ Ï¢ÖÎ£åÎêòÏóàÏäµÎãàÎã§.');
    } else {
      setWinnerMessage('');
    }
  };
  
  const playAIMove = async () => {
    try {
      const res = await fetch(`${BACKEND_URL}/ai/move`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ fen: game.fen(), level: aiLevel }),
      });
      const data = await res.json();

      if (!data.move) return;

      const move = game.move({
        from: data.move.slice(0, 2),
        to: data.move.slice(2, 4),
        promotion: 'q', // AIÍ∞Ä Ìè∞ÏùÑ ÏäπÍ∏âÌï† ÏàòÎèÑ ÏûàÏùå
      });

      if (move) {
        setPosition(game.fen());
        updateMovePairs(game.history({ verbose: true }));
        checkGameOver(game);
      }
    } catch (error) {
      console.error('AI Ìò∏Ï∂ú Ïã§Ìå®:', error);
    }
  };

  const onDrop = async ({ sourceSquare, targetSquare }: { sourceSquare: Square; targetSquare: Square }) => {
    if (game.isGameOver()) return;

    if (puzzleActive) {
      try {
        const move = game.move({ from: sourceSquare, to: targetSquare, promotion: 'q' });
        if (!move) return;

        setPosition(game.fen());

        const userMove = move.san.replace(/[+#]*/g, '');
        const correctMove = puzzleSolution[userMoves.length]?.replace(/[+#]*/g, '');

        if (userMove === correctMove) {
          const newUserMoves = [...userMoves, userMove];
          setUserMoves(newUserMoves);

          if (newUserMoves.length === puzzleSolution.length) {
            setPuzzleMessage('üéâ Ï†ïÎãµÏûÖÎãàÎã§!');
            setPuzzleActive(false);
            setUseAI(false);

            // ‚úÖ Ï†êÏàò Í∏∞Î°ù API Ìò∏Ï∂ú
            await fetch(`${BACKEND_URL}/ai/puzzle/submit`, {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                user_id: userId,
                puzzle_id: puzzleId,
                solved: true,
                time: 10  // Ï∂îÌõÑ Ïã§Ï†ú ÌíÄÏù¥ ÏãúÍ∞Ñ ÎÑ£Ïñ¥ÎèÑ OK
              })
            });
          } else {
            setPuzzleMessage('üëç Í≥ÑÏÜç ÏßÑÌñâÌïòÏÑ∏Ïöî');
            setTimeout(() => {
              const nextSan = puzzleSolution[newUserMoves.length];
              const legalMoves = game.moves({ verbose: true });
              const autoMove = legalMoves.find(m => m.san.replace(/[+#]*/g, '') === nextSan.replace(/[+#]*/g, ''));

              if (autoMove) {
                game.move(autoMove);
                setPosition(game.fen());
                setUserMoves([...newUserMoves, autoMove.san.replace(/[+#]*/g, '')]);
                checkGameOver(game);
              }
            }, 500);
          }
        } else {
          game.undo();
          setPosition(game.fen());
          setPuzzleMessage('‚ùå Ïò§ÎãµÏûÖÎãàÎã§. Îã§Ïãú ÏãúÎèÑÌïòÏÑ∏Ïöî.');
        }
      } catch (e) {
        console.error('ÌçºÏ¶ê Ïò§Î•ò:', e);
      }
      return;
    }


    const piece = game.get(sourceSquare);
    if (!piece || piece.color !== game.turn()) return;

    if (isPromotionMove(sourceSquare, targetSquare)) {
      handlePromotion(sourceSquare, targetSquare);
      return;
    }

    try {
      const move = game.move({ from: sourceSquare, to: targetSquare });

      if (move === null) {
        setPosition(game.fen());
        return;
      }

      setPosition(game.fen());
      updateMovePairs(game.history({ verbose: true }));
      checkGameOver(game);
      if (useAI && game.turn() === 'b' && !game.isGameOver()) {
          setTimeout(() => {
            playAIMove();
          }, 300);
        }
    } catch (error) {
      console.warn('ÏûòÎ™ªÎêú ÏàòÏûÖÎãàÎã§:', error);
      setPosition(game.fen()); // ÏõêÎûò ÏúÑÏπòÎ°ú Î≥µÏõê
    }
  };

  const startPuzzle = async () => {
    if (!userId) {
      alert("Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö© Í∞ÄÎä•Ìï©ÎãàÎã§.");
      return;
    }

    const res = await fetch(`${BACKEND_URL}/ai/puzzle?user_id=${userId}`);
    const data = await res.json();
    const newPuzzle = new Chess(data.fen);

    setPuzzleFen(data.fen);
    setPuzzleGame(newPuzzle);
    setPosition(data.fen);
    setPuzzleSolution(data.solution);
    setPuzzleHint(data.hint || '');
    setPuzzleMessage('');
    setShowHint(false);
    setShowSolution(false);
    setPuzzleActive(true);
    setGame(newPuzzle);
    setUserMoves([]);
    setPuzzleId(data.puzzle_id); 
  };

  const resetGame = () => {
    const newGame = new Chess();
    setGame(newGame);
    setPosition(newGame.fen());
    setMovePairs([]);
    setWinnerMessage('');
  };

  useEffect(() => {
    if (!puzzleActive && useAI && game.turn() === 'b' && !game.isGameOver()) {
      const timer = setTimeout(() => {
        playAIMove();
      }, 300);
      return () => clearTimeout(timer); // cleanup
    }
  }, [game.fen(), useAI, puzzleActive]); 

  const turn = game.turn() === 'w' ? 'Î∞±' : 'Ìùë';
  const inCheck = game.inCheck() ? 'Ï≤¥ÌÅ¨!' : '';
  const gameOver = game.isGameOver();

  const renderAIModeToggle = () => (
    <div style={{ textAlign: 'center', marginTop: 10 }}>
      <label style={{ fontSize: 16, marginRight: 10 }}>AIÏôÄ ÎåÄÍµ≠ÌïòÍ∏∞</label>
      <input
        type="checkbox"
        checked={useAI}
        onChange={() => setUseAI(!useAI)}
        style={{ transform: 'scale(1.2)' }}
      />
    </div>
  );

  const renderAIDifficultySelector = () => (
    <div style={{ textAlign: 'center', marginTop: 10 }}>
      <label style={{ fontSize: 16, marginRight: 10 }}>ÎÇúÏù¥ÎèÑ</label>
      <select
        value={aiLevel}
        onChange={(e) => setAiLevel(e.target.value as 'easy' | 'medium' | 'hard')}
        style={{ fontSize: 16, padding: 5 }}
      >
        <option value="easy">üôÉ Î∞îÎ≥¥ ÏàòÏ§Ä</option>
        <option value="medium">üòê ÏÇ¨Îûå Í∞ôÏùÄ ÏàòÏ§Ä</option>
        <option value="hard">ü§ñ ÎßàÏä§ÌÑ∞ AI</option>
      </select>
    </div>
  );

  const renderPromotionModal = () =>
    promotionModalOpen && (
      <div style={{ position: 'fixed', top: 0, left: 0, right: 0, bottom: 0, background: 'rgba(0,0,0,0.5)', display: 'flex', justifyContent: 'center', alignItems: 'center', zIndex: 1000 }}>
        <div style={{ background: 'white', padding: '20px', borderRadius: '8px', textAlign: 'center' }}>
          <h3>ÏäπÍ∏âÌï† Í∏∞Î¨ºÏùÑ ÏÑ†ÌÉùÌïòÏÑ∏Ïöî</h3>
          <div style={{ display: 'flex', justifyContent: 'space-around', marginTop: 10 }}>
            {(['q', 'r', 'b', 'n'] as const).map((p) => (
              <button
                key={p}
                onClick={() => confirmPromotion(p)}
                style={{ fontSize: 20, margin: '0 10px', padding: '10px 20px', borderRadius: 8, cursor: 'pointer' }}>
                {{ q: 'ÌÄ∏', r: 'Î£©', b: 'ÎπÑÏàç', n: 'ÎÇòÏù¥Ìä∏' }[p]}
              </button>
            ))}
          </div>
        </div>
      </div>
    );

  return (
    <>
      {/* Î°úÍ∑∏Ïù∏ ÏòÅÏó≠ */}
      {!userId ? (
        <div style={{ textAlign: 'center', marginTop: 20 }}>
          <h3>üîê Î°úÍ∑∏Ïù∏ ÌõÑ Ïù¥Ïö©ÌïòÏÑ∏Ïöî</h3>
          <input type="email" placeholder="Ïù¥Î©îÏùº" value={email} onChange={e => setEmail(e.target.value)} />
          <input type="password" placeholder="ÎπÑÎ∞ÄÎ≤àÌò∏" value={password} onChange={e => setPassword(e.target.value)} />
          <button onClick={handleLogin}>Î°úÍ∑∏Ïù∏</button>
        </div>
      ) : (
        <div style={{ textAlign: 'center', marginTop: 20 }}>
          <p>‚úÖ Î°úÍ∑∏Ïù∏Îê®: {userId}</p>
          <button onClick={handleLogout}>Î°úÍ∑∏ÏïÑÏõÉ</button>
        </div>
      )}
      {renderPromotionModal()}
      {renderAIModeToggle()}
      {renderAIDifficultySelector()}
      <div style={{ textAlign: 'center', margin: '20px', fontWeight: 'bold', fontSize: 24, color: gameOver ? 'red' : '#333' }}>
        {gameOver ? `üõë ${winnerMessage}` : `üéØ ${turn} Ï∞®Î°ÄÏûÖÎãàÎã§ ${inCheck}`}
      </div>

      {puzzleActive && (
        <div style={{ textAlign: 'center', fontSize: 18, color: '#333' }}>
          {puzzleMessage}
        </div>
      )}

      {puzzleActive && (
        <div style={{ textAlign: 'center', margin: '12px 0' }}>
          <button
            onClick={() => setShowHint(true)}
            style={{ margin: '0 10px', padding: '6px 12px', borderRadius: 6, fontSize: 14 }}
          >
            üí° ÌûåÌä∏ Î≥¥Í∏∞
          </button>
          <button
            onClick={() => setShowSolution(true)}
            style={{ margin: '0 10px', padding: '6px 12px', borderRadius: 6, fontSize: 14 }}
          >
            ‚úÖ Ï†ïÎãµ Î≥¥Í∏∞
          </button>
          <div style={{ marginTop: 10 }}>
            {showHint && <div style={{ fontStyle: 'italic', color: '#555' }}>ÌûåÌä∏: {puzzleHint || 'ÏóÜÏùå'}</div>}
            {showSolution && (
              <div style={{ marginTop: 5 }}>
                Ï†ïÎãµ ÏàòÏàú: {puzzleSolution.join(' ‚Üí ')}
              </div>
            )}
          </div>
        </div>
      )}

      {!puzzleActive && puzzleMessage === 'üéâ Ï†ïÎãµÏûÖÎãàÎã§!' && (
        <button
          onClick={startPuzzle}
          style={{
            display: 'block',
            margin: '10px auto',
            padding: '10px 20px',
            fontWeight: 'bold',
            fontSize: 16,
            borderRadius: 8,
            border: 'none',
            backgroundColor: '#FF9800',
            color: 'white',
            cursor: 'pointer',
            boxShadow: '0 4px 10px rgba(0, 0, 0, 0.2)',
            transition: 'all 0.2s ease-in-out',
          }}
          onMouseOver={(e) => (e.currentTarget.style.backgroundColor = '#F57C00')}
          onMouseOut={(e) => (e.currentTarget.style.backgroundColor = '#FF9800')}
        >
          ‚ñ∂Ô∏è Îã§Ïùå ÌçºÏ¶ê ÎèÑÏ†Ñ
        </button>
      )}

      <div style={{ display: 'flex', justifyContent: 'center', gap: 24 }}>
        <div style={{ width: boardWidth, boxShadow: '0 8px 24px rgba(0, 0, 0, 0.2)', borderRadius: 12, padding: 12, background: 'linear-gradient(145deg, #e4cfa0, #f0d9b5)' }}>
          <Chessboard
            position={position}
            onDrop={onDrop}
            width={boardWidth}
            draggable={true}
            transitionDuration={200}
          />
        </div>

        <div style={{ minWidth: 160, maxHeight: boardWidth, overflowY: 'auto', background: '#fffbe6', padding: 12, borderRadius: 8, boxShadow: '0 0 8px rgba(0,0,0,0.1)' }}>
          <h4>ÏàòÏàú</h4>
            <ul style={{ margin: 0, paddingLeft: 20 }}>
              {movePairs.map(([white, black], i) => (
                <li key={i}>
                  {i + 1}. {white} {black}
                </li>
              ))}
            </ul>
        </div>
      </div>
      
      <button
        onClick={startPuzzle}
        style={{ display: 'block', margin: '20px auto', padding: '12px 24px', fontWeight: 'bold', fontSize: 16, borderRadius: 8, border: 'none', backgroundColor: '#2196F3', color: 'white', cursor: 'pointer', boxShadow: '0 4px 10px rgba(0, 0, 0, 0.2)', transition: 'all 0.2s ease-in-out' }}
        onMouseOver={(e) => (e.currentTarget.style.backgroundColor = '#1976D2')}
        onMouseOut={(e) => (e.currentTarget.style.backgroundColor = '#2196F3')}
      >
        üß© ÌçºÏ¶ê ÏãúÏûëÌïòÍ∏∞
      </button>

      <button
        onClick={resetGame}
        style={{ display: 'block', margin: '20px auto', padding: '12px 24px', fontWeight: 'bold', fontSize: 16, borderRadius: 8, border: 'none', backgroundColor: '#4CAF50', color: 'white', cursor: 'pointer', boxShadow: '0 4px 10px rgba(0, 0, 0, 0.2)', transition: 'all 0.2s ease-in-out' }}
        onMouseOver={(e) => (e.currentTarget.style.backgroundColor = '#45A049')}
        onMouseOut={(e) => (e.currentTarget.style.backgroundColor = '#4CAF50')}
      >
        üîÅ Í≤åÏûÑ Îã§Ïãú ÏãúÏûë
      </button>
    </>
  );
}

export default App;
